---
title: "GRAAL : Classification automatique de nomenclatures statistiques par approche agentique"
subtitle: "Graph-based Research with Agents for Automatic Labelling"
author: "SSPlab"
institute: "INSEE"
date: today
date-format: "DD MMMM YYYY"
lang: fr
format:
  revealjs:
    theme: [default, custom.scss]
    # logo: images/logo-insee.png
    footer: "Corps techniques de l'Ã‰tat - 2025"
    slide-number: c/t
    show-slide-number: all
    width: 1920
    height: 1080
    margin: 0.05
    center: true
    navigation-mode: vertical
    controls-layout: bottom-right
    controls-tutorial: false
    history: true
    hash-type: number
    transition: slide
    transition-speed: default
    background-transition: fade
    incremental: false
    code-fold: false
    code-line-numbers: false
    code-copy: true
    highlight-style: github
    fig-align: center
    fig-cap-location: bottom
    toc: false
    toc-depth: 1
    number-sections: false
    embed-resources: true
execute:
  echo: true
  warning: false
  message: false
  cache: true
bibliography: references.bib
---

## Plan {.smaller}


1. **Contexte**. DÃ©fis de la classification statistique : des classifications hiÃ©rarchiques Ã  haute granularitÃ©  
2. **Le Framework GRAAL**. Architecture multi-agents
3. **Perspectives**. DÃ©veloppements futurs


# Contexte 

## Classification dans les nomenclatures officielles


### Nomenclatures INSEE

:::: {.columns}

::: {.column width="60%"}

- **NACE** : Nomenclature statistique des ActivitÃ©s Ã©conomiques dans la CommunautÃ© EuropÃ©enne
    - ~650 codes finaux
    - Structure hiÃ©rarchique sur 4 niveaux
  
- **COICOP** : Classification of Individual Consumption by Purpose
    - ~300 Ã  ~1000 selon la granularitÃ© employÃ©e
    - Structure hiÃ©rarchique sur 5 niveaux

### DÃ©fis actuels

- **Volume** : Flux importants de labels Ã  classifier : ~X entreprises Ã  labelliser par jour
- **Temps** : Annotation manuelle coÃ»teuse
- **PrÃ©cision** : Exigences de qualitÃ© statistique
- **TraÃ§abilitÃ©** : Audit et justification


:::

::: {.column width="40%}

```{mermaid}
graph TD
  %% Sections
  S_A["Section A<br/>Agriculture, sylviculture et pÃªche"]
  S_C["Section C<br/>Industrie manufacturiÃ¨re"]

  %% Divisions
  D_01["Division 01<br/>Culture et production animale"]
  D_10["Division 10<br/>Industries alimentaires"]

  %% Groupes
  G_01_1["Groupe 01.1<br/>Cultures non permanentes"]
  G_10_1["Groupe 10.1<br/>Transformation et conservation de la viande"]

  %% Classes
  C_01_11["Classe 01.11<br/>Culture de cÃ©rÃ©ales"]
  C_10_11["Classe 10.11<br/>Transformation de la viande"]

  %% Relations
  S_A --> D_01
  S_C --> D_10

  D_01 --> G_01_1
  D_10 --> G_10_1

  G_01_1 --> C_01_11
  G_10_1 --> C_10_11
```
:::
::::

## Les mÃ©thodes utilisÃ©es aujourd'hui nÃ©cessite des bases de donnÃ©es consÃ©quentes


Dans le cas de la NACE, l'INSEE utilise un classifieur fast-text prÃ©-entrainÃ© avec une accuracy de 88% 

>[!WARNING]
> Plusieurs limites Ã  cette approche :
> - NÃ©cessite un dataset d'entraÃ®nement important (1M de labels pour les codes NACE) : pose problÃ¨me lors d'une crÃ©ation/changement de nomenclature
> - ImpossibilitÃ© d'Ã©valuer la qualitÃ© du dataset d'entraÃ®nement

<!-- TODO: Ajouter le graphe de l'accuracy en fonction de la taille du dataset d'entrainement -->

### Utiliser un LLM pour faire de la classification

<!-- TODO: faire un run avec des llm-only, ajouter l'exemple --> 

### Limites identifiÃ©es

1. **Context window** limitÃ©e :
    - gpt-oss 120B :  128k tokens soit ~100 000 mots
    - Notice NACE:  notice NACE sature le context window

2. **Inconsistance**
   - RÃ©sultats variables entre runs
   - Hallucinations sur codes rares

3. **BoÃ®te noire**
   - Audit impossible
   - Pas la main sur le modÃ¨le

4. **Temps d'infÃ©rence et moyens nÃ©cessaires**
   - ~1s pour une requÃªte
   - NÃ©cessite un GPU en production

## Utiliser la reprÃ©sentation par embeddings
> Mettre en place un RAG ? 
> ReprÃ©sentation insuffisante: 
> - les notices sont denses en concepts
> - Elles possÃ¨dent une organisation particuliÃ¨re Ã  exploiter (includes, not includes -> difficultÃ©s dans le choix du chunk)
> Se trouvent dans un espace diffÃ©rent des labels 

<!-- TODO: Ajouter une visualisation t-SNE -->  

# **Le Framework GRAAL**. Architecture multi-agents 


## ReprÃ©sentation par arbre hiÃ©rarchique de la nomenclature NACE avec Neo4J

La nomenclature NACE est reprÃ©sentÃ©e comme un arbre hiÃ©rarchique. 

:::: {.columns}

::: {.column width = 30%}
<!-- Ajouter une reprÃ©sentation complÃ¨te d'une notice NACE -->
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Chunk             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CODE        : 60             â”‚
â”‚ LEVEL       : 2              â”‚
â”‚ NAME        : ActivitÃ©s de   â”‚
â”‚              programmation   â”‚
â”‚              et diffusion    â”‚
â”‚ parent_code : J              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Includes    : â€¦              â”‚
â”‚ Excludes    : â€¦              â”‚
â”‚ text        : description    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ embedding   : vecteur de     â”‚
â”‚              dimension N     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
:::

::: {.column width = 70%}
```{mermaid}
graph TD
  ROOT["Root"]

  %% Sections
  J["CODE: J<br/>LEVEL: 1"]
  A["CODE: A<br/>LEVEL: 1"]

  %% Divisions
  J60["CODE: J60<br/>LEVEL: 2"]
  J61["CODE: J61<br/>LEVEL: 2"]
  A01["CODE: A01<br/>LEVEL: 2"]

  %% Groupes
  J60_1["CODE: J60.1<br/>LEVEL: 3"]
  J60_2["CODE: J60.2<br/>LEVEL: 3"]
  A01_1["CODE: A01.1<br/>LEVEL: 3"]

  %% Classes
  J60_11["CODE: J60.11<br/>LEVEL: 4"]
  J60_12["CODE: J60.12<br/>LEVEL: 4"]
  A01_11["CODE: A01.11<br/>LEVEL: 4"]

  %% Relations HAS_PARENT
  J -->|HAS_PARENT| ROOT
  A -->|HAS_PARENT| ROOT

  J60 -->|HAS_PARENT| J
  J61 -->|HAS_PARENT| J
  A01 -->|HAS_PARENT| A

  J60_1 -->|HAS_PARENT| J60
  J60_2 -->|HAS_PARENT| J60
  A01_1 -->|HAS_PARENT| A01

  J60_11 -->|HAS_PARENT| J60_1
  J60_12 -->|HAS_PARENT| J60_1
  A01_11 -->|HAS_PARENT| A01_1

```
:::

::::

## Utilisation du graph comme support pour des agents
<!-- TODO: GÃ©rer les outils prÃ©sents dans le code, il manque toute la partie navigation --> 
On dÃ©finit un ensemble d'outil afin qu'un agent puisse parcourir le graph : 
- Des outils se renseigner sur le graph: 
    - get_code_information
    - get_children
    - get_descendants 
    - get_siblings



```{mermaid}
%%{init: {'theme':'base', 'themeVariables': { 'fontSize': '16px'}}}%%
flowchart TB
    Input["ğŸ¢ Description entreprise"]
    
    subgraph GRAAL["Framework GRAAL"]
        GA["ğŸ” Graph Agent<br/>Navigation hiÃ©rarchique"]
        RA["ğŸ“š RAG Agent<br/>Recherche contextuelle"]
        EA["âœ… Evaluation Agent<br/>Validation & scoring"]
        
        subgraph KG["Knowledge Graph"]
            N1["NACE Codes"]
            N2["Relations"]
            N3["Descriptions"]
        end
    end
    
    Output["ğŸ“Š Code + Confiance + Justification"]
    
    Input --> GA
    GA <--> KG
    GA --> RA
    RA <--> KG
    RA --> EA
    EA --> Output
    
    style GRAAL fill:#e8f5e9
    style KG fill:#fff3e0
```

## Navigation dans le graphe

:::: {.columns}

::: {.column width="50%"}
### Approche hiÃ©rarchique
```python
# Navigation intelligente
class GraphNavigator:
    def navigate(self, description):
        # 1. Identifier section (A-U)
        section = self.find_section(description)
        
        # 2. Descendre division (01-99)
        division = self.explore_division(
            section, description
        )
        
        # 3. Raffiner groupe/classe
        return self.refine_classification(
            division, description
        )
```
:::

::: {.column width="50%"}
### Avantages

âœ… **Exploration guidÃ©e**
- Suit la structure NACE
- RÃ©duit l'espace de recherche

âœ… **TraÃ§abilitÃ© complÃ¨te**
- Chemin de dÃ©cision clair
- Justifications Ã  chaque Ã©tape

âœ… **CohÃ©rence garantie**
- Respect des contraintes hiÃ©rarchiques
- Pas de codes invalides
:::

::::


## Code : Agent de navigation
```{python}
#| echo: true
#| eval: false
#| code-line-numbers: "|1-3|5-8|10-16|18-22"

from langchain.agents import AgentExecutor
from neo4j import GraphDatabase
from typing import Dict, List

class NavigatorAgent:
    def __init__(self, graph_uri: str):
        self.driver = GraphDatabase.driver(graph_uri)
        self.tools = self._create_navigation_tools()
    
    def classify(self, description: str) -> Dict:
        # 1. Analyse initiale
        context = self.extract_features(description)
        
        # 2. Navigation hiÃ©rarchique
        path = self.navigate_hierarchy(context)
        
        # 3. Validation finale
        result = self.validate_classification(path)
        
        return {
            "code": result.code,
            "confidence": result.confidence,
            "justification": result.explanation
        }
```

## Exemple de classification

::: {.panel-tabset}

### Input
```python
description = """
Entreprise de fabrication artisanale de pains spÃ©ciaux 
et viennoiseries, avec vente directe en boutique
"""
```

### Output
```json
{
  "code": "10.71Z",
  "label": "Fabrication de pain et pÃ¢tisserie fraÃ®che",
  "confidence": 0.94,
  "path": ["C", "10", "10.7", "10.71", "10.71Z"],
  "justification": "Fabrication artisanale (C) de produits 
                    de boulangerie (10.7) avec vente directe"
}
```

:::


::: {.callout-note}
Ã‰valuation sur 1,800 entreprises annotÃ©es manuellement (golden dataset)
:::

## MÃ©triques dÃ©taillÃ©es

:::: {.columns}

::: {.column width="50%"}
### Performances quantitatives

| MÃ©trique | Baseline | GRAAL | Gain |
|----------|----------|-------|------|
| PrÃ©cision Top-1 | 70% | **89%** | +19% |
| PrÃ©cision Top-3 | 82% | **96%** | +14% |
| Rappel | 68% | **87%** | +19% |
| F1-Score | 0.69 | **0.88** | +0.19 |
| Temps mÃ©dian | 120ms | 450ms | +330ms |

:::

::: {.column width="50%"}
### Avantages qualitatifs

âœ… **ExplicabilitÃ©** : 100% des dÃ©cisions justifiÃ©es

âœ… **CohÃ©rence** : <2% de variance inter-runs

âœ… **AuditabilitÃ©** : Trace complÃ¨te du raisonnement

âœ… **AdaptabilitÃ©** : Mise Ã  jour facile des rÃ¨gles

âœ… **ScalabilitÃ©** : 10K classifications/heure
:::

::::

<!-- TODO: Mettre Ã  jour ce graph -->
## Analyse des erreurs
```{python}
#| echo: false
#| fig-width: 10
#| fig-height: 5

import plotly.graph_objects as go

errors = ['AmbiguÃ¯tÃ© mÃ©tier', 'ActivitÃ©s multiples', 'Description incomplÃ¨te', 
          'Code obsolÃ¨te', 'Erreur annotation', 'Autres']
counts = [35, 28, 20, 8, 5, 4]
colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#fdcb6e', '#6c5ce7', '#a8e6cf']

fig = go.Figure(data=[
    go.Pie(labels=errors, values=counts, hole=.3,
           marker=dict(colors=colors, line=dict(color='white', width=2)))
])

fig.update_layout(
    title="Distribution des erreurs de classification",
    height=350
)

fig.show()
```

::: {.callout-important}
**Principale source d'erreur** : Entreprises multi-activitÃ©s nÃ©cessitant une analyse du chiffre d'affaires
:::

# DÃ©monstration {background-color="#00897B"}
<!-- TODO: Mettre Ã  jour la dÃ©mo avec le vrai code -->  
## DÃ©monstration
```{python}
#| echo: false
#| eval: false

# Code pour une dÃ©mo interactive (non exÃ©cutÃ© dans les slides)
import ipywidgets as widgets
from IPython.display import display, HTML

description_input = widgets.Textarea(
    value='Boulangerie artisanale avec salon de thÃ©',
    placeholder='DÃ©crivez l\'activitÃ© de l\'entreprise...',
    description='Description:',
    layout=widgets.Layout(width='100%', height='100px')
)

classify_button = widgets.Button(
    description='Classifier',
    button_style='success',
    icon='check'
)

output = widgets.Output()

def on_classify(b):
    with output:
        output.clear_output()
        # Simulation de classification
        print("âœ… Code: 10.71Z")
        print("ğŸ“Š Confiance: 94%")
        print("ğŸ“ Justification: ActivitÃ© principale de boulangerie")

classify_button.on_click(on_classify)

display(description_input, classify_button, output)
```


# Conclusion

## Points clÃ©s

::: {.incremental .r-fit-text}
- **Solution opÃ©rationnelle** pour la classification automatique
- **Gain de productivitÃ©** significatif (+70% de rapiditÃ©)
- **QualitÃ© maintenue** avec traÃ§abilitÃ© complÃ¨te
- **Architecture extensible** Ã  d'autres nomenclatures
- **Approche innovante** combinant LLMs et graphes
:::

::: {.r-fit-text}
# Questions ?

ğŸ”— [github.com/InseeFrLab/GRAAL](https://github.com/InseeFrLab/GRAAL)

ğŸ“Š [SSPLab - INSEE Innovation](https://ssplab.insee.fr)
:::