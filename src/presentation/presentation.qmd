---
title: "GRAAL : Classification automatique de nomenclatures statistiques par approche agentique"
subtitle: "Graph-based Research with Agents for Automatic Labelling"
author: "SSPlab"
institute: "INSEE"
date: today
date-format: "DD MMMM YYYY"
lang: fr
format:
  revealjs:
    theme: [default, custom.scss]
    # logo: images/logo-insee.png
    footer: "Corps techniques de l'√âtat - 2025"
    slide-number: c/t
    show-slide-number: all
    width: 1920
    height: 1080
    margin: 0.05
    center: true
    navigation-mode: vertical
    controls-layout: bottom-right
    controls-tutorial: false
    history: true
    hash-type: number
    transition: slide
    transition-speed: default
    background-transition: fade
    incremental: false
    code-fold: false
    code-line-numbers: false
    highlight-style: github
    fig-align: center
    fig-cap-location: bottom
    toc: false
    toc-depth: 1
    number-sections: false
    embed-resources: true
    mermaid: 
      theme: neutral
execute:
  echo: false
  warning: false
  message: false
  cache: false
bibliography: references.bib
---

## Plan {.smaller}


1. **Contexte**. D√©fis de la classification statistique : des classifications hi√©rarchiques √† haute granularit√©  
2. **Le Framework GRAAL**. Architecture multi-agents
3. **Perspectives**. D√©veloppements futurs


# **Contexte**. D√©fis de la classification statistique : des classifications hi√©rarchiques √† haute granularit√©  

## Classification dans les nomenclatures officielles

:::: {.columns}
::: {.column width="60%"}
### Nomenclatures INSEE
- **NACE** : Nomenclature statistique des Activit√©s √©conomiques dans la Communaut√© Europ√©enne
    - ~650 codes finaux
    - Structure hi√©rarchique sur 4 niveaux
  
- **COICOP** : Classification of Individual Consumption by Purpose
    - ~300 √† ~1000 selon la granularit√© employ√©e
    - Structure hi√©rarchique sur 5 niveaux

### D√©fis actuels
- **Volume** : Flux importants de labels √† classifier : ~X entreprises √† labelliser par jour
- **Temps** : Annotation manuelle co√ªteuse
- **Pr√©cision** : Exigences de qualit√© statistique
- **Tra√ßabilit√©** : Audit et justification
:::

::: {.column width="40%"}
```{mermaid}
graph TD
  %% Sections
  S_A["Section A<br/>Agriculture, sylviculture et p√™che"]
  S_C["Section C<br/>Industrie manufacturi√®re"]

  %% Divisions
  D_01["Division 01<br/>Culture et production animale"]
  D_10["Division 10<br/>Industries alimentaires"]

  %% Groupes
  G_01_1["Groupe 01.1<br/>Cultures non permanentes"]
  G_10_1["Groupe 10.1<br/>Transformation et conservation de la viande"]

  %% Classes
  C_01_11["Classe 01.11<br/>Culture de c√©r√©ales"]
  C_10_11["Classe 10.11<br/>Transformation de la viande"]

  %% Relations
  S_A --> D_01
  S_C --> D_10

  D_01 --> G_01_1
  D_10 --> G_10_1

  G_01_1 --> C_01_11
  G_10_1 --> C_10_11
```
:::
::::

## Les m√©thodes utilis√©es aujourd'hui n√©cessitent des bases de donn√©es cons√©quentes


Dans le cas de la NACE, l'INSEE utilise un classifieur fast-text pr√©-entrain√© avec une accuracy de 88% 

Plusieurs limites √† cette approche :
- N√©cessite un dataset d'entra√Ænement important (1M de labels pour les codes NACE) : pose probl√®me lors d'une cr√©ation/changement de nomenclature
- Impossibilit√© d'√©valuer la qualit√© du dataset d'entra√Ænement

<!-- TODO: Ajouter le graphe de l'accuracy en fonction de la taille du dataset d'entrainement -->

## Utiliser un LLM pour faire de la classification

<!-- TODO: faire un run avec des llm-only, ajouter l'exemple --> 

Limites identifi√©es :

1. **Context window** limit√©e :
    - gpt-oss 120B :  128k tokens soit ~100 000 mots
    - Notice NACE:  notice NACE sature le context window

2. **Inconsistance**
   - R√©sultats variables entre runs
   - Hallucinations sur codes rares

3. **Bo√Æte noire**
   - Audit impossible
   - Pas la main sur le mod√®le

4. **Temps d'inf√©rence et moyens n√©cessaires**
   - ~1s pour une requ√™te
   - N√©cessite un GPU en production

## Utiliser la repr√©sentation par embeddings
Mettre en place un RAG ? 
Repr√©sentation insuffisante: 
- les notices sont denses en concepts
- Elles poss√®dent une organisation particuli√®re √† exploiter (includes, not includes -> difficult√©s dans le choix du chunk)
- Se trouvent dans un espace diff√©rent des labels 

<!-- TODO: Ajouter une visualisation t-SNE -->  

# **Le Framework GRAAL**. Architecture multi-agents


## Repr√©sentation par arbre hi√©rarchique de la nomenclature NACE avec Neo4J

La nomenclature NACE est repr√©sent√©e comme un arbre hi√©rarchique. 

:::: {.columns}
::: {.column width="30%"}
<!-- Ajouter une repr√©sentation compl√®te d'une notice NACE -->
+--------------+------------------------------------------+
| Champ        | Valeur                                   |
+==============+==========================================+
| CODE         | 60                                       |
| LEVEL        | 2                                        |
| NAME         | Activit√©s de programmation et diffusion  |
| parent_code  | J                                        |
| Includes     | ‚Ä¶                                        |
| Excludes     | ‚Ä¶                                        |
| text         | description                              |
| embedding    | vecteur de dimension N                   |
+--------------+------------------------------------------+
:::

::: {.column width="70%"}
```{mermaid}
graph TD
  ROOT["Root"]

  %% Sections
  J["CODE: J<br/>LEVEL: 1"]
  A["CODE: A<br/>LEVEL: 1"]

  %% Divisions
  J60["CODE: J60<br/>LEVEL: 2"]
  J61["CODE: J61<br/>LEVEL: 2"]
  A01["CODE: A01<br/>LEVEL: 2"]

  %% Groupes
  J60_1["CODE: J60.1<br/>LEVEL: 3"]
  J60_2["CODE: J60.2<br/>LEVEL: 3"]
  A01_1["CODE: A01.1<br/>LEVEL: 3"]

  %% Classes
  J60_11["CODE: J60.11<br/>LEVEL: 4"]
  J60_12["CODE: J60.12<br/>LEVEL: 4"]
  A01_11["CODE: A01.11<br/>LEVEL: 4"]

  %% Relations HAS_PARENT
  J -->|HAS_PARENT| ROOT
  A -->|HAS_PARENT| ROOT

  J60 -->|HAS_PARENT| J
  J61 -->|HAS_PARENT| J
  A01 -->|HAS_PARENT| A

  J60_1 -->|HAS_PARENT| J60
  J60_2 -->|HAS_PARENT| J60
  A01_1 -->|HAS_PARENT| A01

  J60_11 -->|HAS_PARENT| J60_1
  J60_12 -->|HAS_PARENT| J60_1
  A01_11 -->|HAS_PARENT| A01_1

```
:::
::::

## Utilisation du graph comme support pour des agents
<!-- TODO: G√©rer les outils pr√©sents dans le code, il manque toute la partie navigation --> 
On d√©finit un ensemble d'outil afin qu'un agent puisse parcourir le graph : 
- Des outils se renseigner sur le graph: 
    - get_code_information
    - get_children
    - get_descendants 
    - get_siblings



```{mermaid}
%%{init: {'theme':'base', 'themeVariables': { 'fontSize': '16px'}}}%%
flowchart TB
    Input["üè¢ Description entreprise"]
    
    subgraph GRAAL["Framework GRAAL"]
        GA["üîç Graph Agent<br/>Navigation hi√©rarchique"]
        RA["üìö RAG Agent<br/>Recherche contextuelle"]
        EA["‚úÖ Evaluation Agent<br/>Validation & scoring"]
        
        subgraph KG["Knowledge Graph"]
            N1["NACE Codes"]
            N2["Relations"]
            N3["Descriptions"]
        end
    end
    
    Output["üìä Code + Confiance + Justification"]
    
    Input --> GA
    GA <--> KG
    GA --> RA
    RA <--> KG
    RA --> EA
    EA --> Output
    
    style GRAAL fill:#e8f5e9
    style KG fill:#fff3e0
```

## Navigation dans le graphe

:::: {.columns}

::: {.column width="50%"}
### Approche hi√©rarchique
```python
# Navigation intelligente
class GraphNavigator:
    def navigate(self, description):
        # 1. Identifier section (A-U)
        section = self.find_section(description)
        
        # 2. Descendre division (01-99)
        division = self.explore_division(
            section, description
        )
        
        # 3. Raffiner groupe/classe
        return self.refine_classification(
            division, description
        )
```
:::

::: {.column width="50%"}
### Avantages

‚úÖ **Exploration guid√©e**
- Suit la structure NACE
- R√©duit l'espace de recherche

‚úÖ **Tra√ßabilit√© compl√®te**
- Chemin de d√©cision clair
- Justifications √† chaque √©tape

‚úÖ **Coh√©rence garantie**
- Respect des contraintes hi√©rarchiques
- Pas de codes invalides
:::

::::


## Code : Agent de navigation
```{python}
#| echo: true
#| eval: false
#| code-line-numbers: "|1-3|5-8|10-16|18-22"

from langchain.agents import AgentExecutor
from neo4j import GraphDatabase
from typing import Dict, List

class NavigatorAgent:
    def __init__(self, graph_uri: str):
        self.driver = GraphDatabase.driver(graph_uri)
        self.tools = self._create_navigation_tools()
    
    def classify(self, description: str) -> Dict:
        # 1. Analyse initiale
        context = self.extract_features(description)
        
        # 2. Navigation hi√©rarchique
        path = self.navigate_hierarchy(context)
        
        # 3. Validation finale
        result = self.validate_classification(path)
        
        return {
            "code": result.code,
            "confidence": result.confidence,
            "justification": result.explanation
        }
```

## Exemple de classification

::: {.panel-tabset}

### Input
```python
description = """
Entreprise de fabrication artisanale de pains sp√©ciaux 
et viennoiseries, avec vente directe en boutique
"""
```

### Output
```json
{
  "code": "10.71Z",
  "label": "Fabrication de pain et p√¢tisserie fra√Æche",
  "confidence": 0.94,
  "path": ["C", "10", "10.7", "10.71", "10.71Z"],
  "justification": "Fabrication artisanale (C) de produits 
                    de boulangerie (10.7) avec vente directe"
}
```

:::


::: {.callout-note}
√âvaluation sur 1,800 entreprises annot√©es manuellement (golden dataset)
:::

## M√©triques d√©taill√©es

:::: {.columns}

::: {.column width="50%"}
### Performances quantitatives

| M√©trique | Baseline | GRAAL | Gain |
|----------|----------|-------|------|
| Pr√©cision Top-1 | 70% | **89%** | +19% |
| Pr√©cision Top-3 | 82% | **96%** | +14% |
| Rappel | 68% | **87%** | +19% |
| F1-Score | 0.69 | **0.88** | +0.19 |
| Temps m√©dian | 120ms | 450ms | +330ms |

:::

::: {.column width="50%"}
### Avantages qualitatifs

‚úÖ **Explicabilit√©** : 100% des d√©cisions justifi√©es

‚úÖ **Coh√©rence** : <2% de variance inter-runs

‚úÖ **Auditabilit√©** : Trace compl√®te du raisonnement

‚úÖ **Adaptabilit√©** : Mise √† jour facile des r√®gles

‚úÖ **Scalabilit√©** : 10K classifications/heure
:::

::::

<!-- TODO: Mettre √† jour ce graph -->
## Analyse des erreurs
```{python}
#| echo: false
#| fig-width: 10
#| fig-height: 5

import plotly.graph_objects as go

errors = ['Ambigu√Øt√© m√©tier', 'Activit√©s multiples', 'Description incompl√®te', 
          'Code obsol√®te', 'Erreur annotation', 'Autres']
counts = [35, 28, 20, 8, 5, 4]
colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#fdcb6e', '#6c5ce7', '#a8e6cf']

fig = go.Figure(data=[
    go.Pie(labels=errors, values=counts, hole=.3,
           marker=dict(colors=colors, line=dict(color='white', width=2)))
])

fig.update_layout(
    title="Distribution des erreurs de classification",
    height=350
)

fig.show()
```

::: {.callout-important}
**Principale source d'erreur** : Entreprises multi-activit√©s n√©cessitant une analyse du chiffre d'affaires
:::

# D√©monstration {background-color="#00897B"}
<!-- TODO: Mettre √† jour la d√©mo avec le vrai code -->  
## D√©monstration
```{python}
#| echo: false
#| eval: false

# Code pour une d√©mo interactive (non ex√©cut√© dans les slides)
import ipywidgets as widgets
from IPython.display import display, HTML

description_input = widgets.Textarea(
    value='Boulangerie artisanale avec salon de th√©',
    placeholder='D√©crivez l\'activit√© de l\'entreprise...',
    description='Description:',
    layout=widgets.Layout(width='100%', height='100px')
)

classify_button = widgets.Button(
    description='Classifier',
    button_style='success',
    icon='check'
)

output = widgets.Output()

def on_classify(b):
    with output:
        output.clear_output()
        # Simulation de classification
        print("‚úÖ Code: 10.71Z")
        print("üìä Confiance: 94%")
        print("üìù Justification: Activit√© principale de boulangerie")

classify_button.on_click(on_classify)

display(description_input, classify_button, output)
```


# Conclusion

## Points cl√©s

::: {.incremental .r-fit-text}
- **Solution op√©rationnelle** pour la classification automatique
- **Gain de productivit√©** significatif (+70% de rapidit√©)
- **Qualit√© maintenue** avec tra√ßabilit√© compl√®te
- **Architecture extensible** √† d'autres nomenclatures
- **Approche innovante** combinant LLMs et graphes
:::

::: {.r-fit-text}
# Questions ?

üîó [github.com/InseeFrLab/GRAAL](https://github.com/InseeFrLab/GRAAL)

üìä [SSPLab - INSEE Innovation](https://ssplab.insee.fr)
:::